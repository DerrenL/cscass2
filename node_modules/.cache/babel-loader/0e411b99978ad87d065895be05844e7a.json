{"ast":null,"code":"/*\n This file is auto-generated, do not edit\n*/\n'use strict';\n\nvar _classCallCheck = require(\"D:\\\\material-kit-react-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:\\\\material-kit-react-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"D:\\\\material-kit-react-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:\\\\material-kit-react-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar rqs = require(\"./request\");\n/**\n * Recommends set of items that are somehow related to one given item, *X*. Typical scenario  is when user *A* is viewing *X*. Then you may display items to the user that he might be also interested in. Recommend items to item request gives you Top-N such items, optionally taking the target user *A* into account.\n * It is also possible to use POST HTTP method (for example in case of very long ReQL filter) - query parameters then become body parameters.\n * The returned items are sorted by relevancy (first item being the most relevant).\n */\n\n\nvar RecommendItemsToItem = /*#__PURE__*/function (_rqs$Request) {\n  _inherits(RecommendItemsToItem, _rqs$Request);\n\n  var _super = _createSuper(RecommendItemsToItem);\n\n  /**\n   * Construct the request\n   * @param {string} itemId - ID of the item for which the recommendations are to be generated.\n   * @param {string} targetUserId - ID of the user who will see the recommendations.\n   * Specifying the *targetUserId* is beneficial because:\n   * * It makes the recommendations personalized\n   * * Allows the calculation of Actions and Conversions\n   *   in the graphical user interface,\n   *   as Recombee can pair the user who got recommendations\n   *   and who afterwards viewed/purchased an item.\n   * If you insist on not specifying the user, pass `null`\n   * (`None`, `nil`, `NULL` etc. depending on language) to *targetUserId*.\n   * Do not create some special dummy user for getting recommendations,\n   * as it could mislead the recommendation models,\n   * and result in wrong recommendations.\n   * For anonymous/unregistered users it is possible to use for example their session ID.\n   * @param {number} count - Number of items to be recommended (N for the top-N recommendation).\n   * @param {Object} optional - Optional parameters given as an object with structure name of the parameter: value\n   * - Allowed parameters:\n   *     - *scenario*\n   *         - Type: string\n   *         - Description: Scenario defines a particular application of recommendations. It can be for example \"homepage\", \"cart\" or \"emailing\".\n   * You can set various settings to the [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com). You can also see performance of each scenario in the Admin UI separately, so you can check how well each application performs.\n   * The AI which optimizes models in order to get the best results may optimize different scenarios separately, or even use different models in each of the scenarios.\n   *     - *cascadeCreate*\n   *         - Type: boolean\n   *         - Description: If item of given *itemId* or user of given *targetUserId* doesn't exist in the database, it creates the missing entity/entities and returns some (non-personalized) recommendations. This allows for example rotations in the following recommendations for the user of given *targetUserId*, as the user will be already known to the system.\n   *     - *returnProperties*\n   *         - Type: boolean\n   *         - Description: With `returnProperties=true`, property values of the recommended items are returned along with their IDs in a JSON dictionary. The acquired property values can be used for easy displaying of the recommended items to the user. \n   * Example response:\n   * ```\n   *   {\n   *     \"recommId\": \"0c6189e7-dc1a-429a-b613-192696309361\",\n   *     \"recomms\":\n   *       [\n   *         {\n   *           \"id\": \"tv-178\",\n   *           \"values\": {\n   *             \"description\": \"4K TV with 3D feature\",\n   *             \"categories\":   [\"Electronics\", \"Televisions\"],\n   *             \"price\": 342,\n   *             \"url\": \"myshop.com/tv-178\"\n   *           }\n   *         },\n   *         {\n   *           \"id\": \"mixer-42\",\n   *           \"values\": {\n   *             \"description\": \"Stainless Steel Mixer\",\n   *             \"categories\":   [\"Home & Kitchen\"],\n   *             \"price\": 39,\n   *             \"url\": \"myshop.com/mixer-42\"\n   *           }\n   *         }\n   *       ]\n   *   }\n   * ```\n   *     - *includedProperties*\n   *         - Type: string[]\n   *         - Description: Allows to specify, which properties should be returned when `returnProperties=true` is set. The properties are given as a comma-separated list. \n   * Example response for `includedProperties=description,price`:\n   * ```\n   *   {\n   *     \"recommId\": \"6842c725-a79f-4537-a02c-f34d668a3f80\",\n   *     \"recomms\": \n   *       [\n   *         {\n   *           \"id\": \"tv-178\",\n   *           \"values\": {\n   *             \"description\": \"4K TV with 3D feature\",\n   *             \"price\": 342\n   *           }\n   *         },\n   *         {\n   *           \"id\": \"mixer-42\",\n   *           \"values\": {\n   *             \"description\": \"Stainless Steel Mixer\",\n   *             \"price\": 39\n   *           }\n   *         }\n   *       ]\n   *   }\n   * ```\n   *     - *filter*\n   *         - Type: string\n   *         - Description: Boolean-returning [ReQL](https://docs.recombee.com/reql.html) expression which allows you to filter recommended items based on the values of their attributes.\n   * Filters can be also assigned to a [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com).\n   *     - *booster*\n   *         - Type: string\n   *         - Description: Number-returning [ReQL](https://docs.recombee.com/reql.html) expression which allows you to boost recommendation rate of some items based on the values of their attributes.\n   * Boosters can be also assigned to a [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com).\n   *     - *logic*\n   *         - Type: string|\n   *         - Description: Logic specifies particular behavior of the recommendation models. You can pick tailored logic for your domain and use case.\n   * See [this section](https://docs.recombee.com/recommendation_logics.html) for list of available logics and other details.\n   * The difference between `logic` and `scenario` is that `logic` specifies mainly behavior, while `scenario` specifies the place where recommendations are shown to the users.\n   * Logic can be also set to a [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com).\n   *     - *userImpact*\n   *         - Type: number\n   *         - Description: **Expert option** If *targetUserId* parameter is present, the recommendations are biased towards the given user. Using *userImpact*, you may control this bias. For an extreme case of `userImpact=0.0`, the interactions made by the user are not taken into account at all (with the exception of history-based blacklisting), for `userImpact=1.0`, you'll get user-based recommendation. The default value is `0`.\n   *     - *diversity*\n   *         - Type: number\n   *         - Description: **Expert option** Real number from [0.0, 1.0] which determines how much mutually dissimilar should the recommended items be. The default value is 0.0, i.e., no diversification. Value 1.0 means maximal diversification.\n   *     - *minRelevance*\n   *         - Type: string\n   *         - Description: **Expert option** If the *targetUserId* is provided:  Specifies the threshold of how much relevant must the recommended items be to the user. Possible values one of: \"low\", \"medium\", \"high\". The default value is \"low\", meaning that the system attempts to recommend number of items equal to *count* at any cost. If there are not enough data (such as interactions or item properties), this may even lead to bestseller-based recommendations to be appended to reach the full *count*. This behavior may be suppressed by using \"medium\" or \"high\" values. In such case, the system only recommends items of at least the requested relevancy, and may return less than *count* items when there is not enough data to fulfill it.\n   *     - *rotationRate*\n   *         - Type: number\n   *         - Description: **Expert option** If the *targetUserId* is provided: If your users browse the system in real-time, it may easily happen that you wish to offer them recommendations multiple times. Here comes the question: how much should the recommendations change? Should they remain the same, or should they rotate? Recombee API allows you to control this per-request in backward fashion. You may penalize an item for being recommended in the near past. For the specific user, `rotationRate=1` means maximal rotation, `rotationRate=0` means absolutely no rotation. You may also use, for example `rotationRate=0.2` for only slight rotation of recommended items.\n   *     - *rotationTime*\n   *         - Type: number\n   *         - Description: **Expert option** If the *targetUserId* is provided: Taking *rotationRate* into account, specifies how long time it takes to an item to recover from the penalization. For example, `rotationTime=7200.0` means that items recommended less than 2 hours ago are penalized.\n   *     - *expertSettings*\n   *         - Type: \n   *         - Description: Dictionary of custom options.\n   *     - *returnAbGroup*\n   *         - Type: boolean\n   *         - Description: If there is a custom AB-testing running, return name of group to which the request belongs.\n   */\n  function RecommendItemsToItem(itemId, targetUserId, count, optional) {\n    var _this;\n\n    _classCallCheck(this, RecommendItemsToItem);\n\n    _this = _super.call(this, 'POST', \"/recomms/items/\".concat(itemId, \"/items/\"), 3000, false);\n    _this.itemId = itemId;\n    _this.targetUserId = targetUserId;\n    _this.count = count;\n    optional = optional || {};\n    _this.scenario = optional.scenario;\n    _this.cascadeCreate = optional.cascadeCreate;\n    _this.returnProperties = optional.returnProperties;\n    _this.includedProperties = optional.includedProperties;\n    _this.filter = optional.filter;\n    _this.booster = optional.booster;\n    _this.logic = optional.logic;\n    _this.userImpact = optional.userImpact;\n    _this.diversity = optional.diversity;\n    _this.minRelevance = optional.minRelevance;\n    _this.rotationRate = optional.rotationRate;\n    _this.rotationTime = optional.rotationTime;\n    _this.expertSettings = optional.expertSettings;\n    _this.returnAbGroup = optional.returnAbGroup;\n    return _this;\n  }\n  /**\n   * Get body parameters\n   * @return {Object} The values of body parameters (name of parameter: value of the parameter)\n   */\n\n\n  _createClass(RecommendItemsToItem, [{\n    key: \"bodyParameters\",\n    value: function bodyParameters() {\n      var params = {};\n      params.targetUserId = this.targetUserId;\n      params.count = this.count;\n      if (this.scenario !== undefined) params.scenario = this.scenario;\n      if (this.cascadeCreate !== undefined) params.cascadeCreate = this.cascadeCreate;\n      if (this.returnProperties !== undefined) params.returnProperties = this.returnProperties;\n      if (this.includedProperties !== undefined) params.includedProperties = this.includedProperties;\n      if (this.filter !== undefined) params.filter = this.filter;\n      if (this.booster !== undefined) params.booster = this.booster;\n      if (this.logic !== undefined) params.logic = this.logic;\n      if (this.userImpact !== undefined) params.userImpact = this.userImpact;\n      if (this.diversity !== undefined) params.diversity = this.diversity;\n      if (this.minRelevance !== undefined) params.minRelevance = this.minRelevance;\n      if (this.rotationRate !== undefined) params.rotationRate = this.rotationRate;\n      if (this.rotationTime !== undefined) params.rotationTime = this.rotationTime;\n      if (this.expertSettings !== undefined) params.expertSettings = this.expertSettings;\n      if (this.returnAbGroup !== undefined) params.returnAbGroup = this.returnAbGroup;\n      return params;\n    }\n    /**\n     * Get query parameters\n     * @return {Object} The values of query parameters (name of parameter: value of the parameter)\n     */\n\n  }, {\n    key: \"queryParameters\",\n    value: function queryParameters() {\n      var params = {};\n      return params;\n    }\n  }]);\n\n  return RecommendItemsToItem;\n}(rqs.Request);\n\nexports.RecommendItemsToItem = RecommendItemsToItem;","map":{"version":3,"sources":["D:/material-kit-react-master/node_modules/recombee-api-client/lib/requests/recommend-items-to-item.js"],"names":["rqs","require","RecommendItemsToItem","itemId","targetUserId","count","optional","scenario","cascadeCreate","returnProperties","includedProperties","filter","booster","logic","userImpact","diversity","minRelevance","rotationRate","rotationTime","expertSettings","returnAbGroup","params","undefined","Request","exports"],"mappings":"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","sourcesContent":["/*\n This file is auto-generated, do not edit\n*/\n\n'use strict';\nconst rqs = require(\"./request\");\n\n/**\n * Recommends set of items that are somehow related to one given item, *X*. Typical scenario  is when user *A* is viewing *X*. Then you may display items to the user that he might be also interested in. Recommend items to item request gives you Top-N such items, optionally taking the target user *A* into account.\n * It is also possible to use POST HTTP method (for example in case of very long ReQL filter) - query parameters then become body parameters.\n * The returned items are sorted by relevancy (first item being the most relevant).\n */\nclass RecommendItemsToItem extends rqs.Request {\n\n  /**\n   * Construct the request\n   * @param {string} itemId - ID of the item for which the recommendations are to be generated.\n   * @param {string} targetUserId - ID of the user who will see the recommendations.\n   * Specifying the *targetUserId* is beneficial because:\n   * * It makes the recommendations personalized\n   * * Allows the calculation of Actions and Conversions\n   *   in the graphical user interface,\n   *   as Recombee can pair the user who got recommendations\n   *   and who afterwards viewed/purchased an item.\n   * If you insist on not specifying the user, pass `null`\n   * (`None`, `nil`, `NULL` etc. depending on language) to *targetUserId*.\n   * Do not create some special dummy user for getting recommendations,\n   * as it could mislead the recommendation models,\n   * and result in wrong recommendations.\n   * For anonymous/unregistered users it is possible to use for example their session ID.\n   * @param {number} count - Number of items to be recommended (N for the top-N recommendation).\n   * @param {Object} optional - Optional parameters given as an object with structure name of the parameter: value\n   * - Allowed parameters:\n   *     - *scenario*\n   *         - Type: string\n   *         - Description: Scenario defines a particular application of recommendations. It can be for example \"homepage\", \"cart\" or \"emailing\".\n   * You can set various settings to the [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com). You can also see performance of each scenario in the Admin UI separately, so you can check how well each application performs.\n   * The AI which optimizes models in order to get the best results may optimize different scenarios separately, or even use different models in each of the scenarios.\n   *     - *cascadeCreate*\n   *         - Type: boolean\n   *         - Description: If item of given *itemId* or user of given *targetUserId* doesn't exist in the database, it creates the missing entity/entities and returns some (non-personalized) recommendations. This allows for example rotations in the following recommendations for the user of given *targetUserId*, as the user will be already known to the system.\n   *     - *returnProperties*\n   *         - Type: boolean\n   *         - Description: With `returnProperties=true`, property values of the recommended items are returned along with their IDs in a JSON dictionary. The acquired property values can be used for easy displaying of the recommended items to the user. \n   * Example response:\n   * ```\n   *   {\n   *     \"recommId\": \"0c6189e7-dc1a-429a-b613-192696309361\",\n   *     \"recomms\":\n   *       [\n   *         {\n   *           \"id\": \"tv-178\",\n   *           \"values\": {\n   *             \"description\": \"4K TV with 3D feature\",\n   *             \"categories\":   [\"Electronics\", \"Televisions\"],\n   *             \"price\": 342,\n   *             \"url\": \"myshop.com/tv-178\"\n   *           }\n   *         },\n   *         {\n   *           \"id\": \"mixer-42\",\n   *           \"values\": {\n   *             \"description\": \"Stainless Steel Mixer\",\n   *             \"categories\":   [\"Home & Kitchen\"],\n   *             \"price\": 39,\n   *             \"url\": \"myshop.com/mixer-42\"\n   *           }\n   *         }\n   *       ]\n   *   }\n   * ```\n   *     - *includedProperties*\n   *         - Type: string[]\n   *         - Description: Allows to specify, which properties should be returned when `returnProperties=true` is set. The properties are given as a comma-separated list. \n   * Example response for `includedProperties=description,price`:\n   * ```\n   *   {\n   *     \"recommId\": \"6842c725-a79f-4537-a02c-f34d668a3f80\",\n   *     \"recomms\": \n   *       [\n   *         {\n   *           \"id\": \"tv-178\",\n   *           \"values\": {\n   *             \"description\": \"4K TV with 3D feature\",\n   *             \"price\": 342\n   *           }\n   *         },\n   *         {\n   *           \"id\": \"mixer-42\",\n   *           \"values\": {\n   *             \"description\": \"Stainless Steel Mixer\",\n   *             \"price\": 39\n   *           }\n   *         }\n   *       ]\n   *   }\n   * ```\n   *     - *filter*\n   *         - Type: string\n   *         - Description: Boolean-returning [ReQL](https://docs.recombee.com/reql.html) expression which allows you to filter recommended items based on the values of their attributes.\n   * Filters can be also assigned to a [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com).\n   *     - *booster*\n   *         - Type: string\n   *         - Description: Number-returning [ReQL](https://docs.recombee.com/reql.html) expression which allows you to boost recommendation rate of some items based on the values of their attributes.\n   * Boosters can be also assigned to a [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com).\n   *     - *logic*\n   *         - Type: string|\n   *         - Description: Logic specifies particular behavior of the recommendation models. You can pick tailored logic for your domain and use case.\n   * See [this section](https://docs.recombee.com/recommendation_logics.html) for list of available logics and other details.\n   * The difference between `logic` and `scenario` is that `logic` specifies mainly behavior, while `scenario` specifies the place where recommendations are shown to the users.\n   * Logic can be also set to a [scenario](https://docs.recombee.com/scenarios.html) in the [Admin UI](https://admin.recombee.com).\n   *     - *userImpact*\n   *         - Type: number\n   *         - Description: **Expert option** If *targetUserId* parameter is present, the recommendations are biased towards the given user. Using *userImpact*, you may control this bias. For an extreme case of `userImpact=0.0`, the interactions made by the user are not taken into account at all (with the exception of history-based blacklisting), for `userImpact=1.0`, you'll get user-based recommendation. The default value is `0`.\n   *     - *diversity*\n   *         - Type: number\n   *         - Description: **Expert option** Real number from [0.0, 1.0] which determines how much mutually dissimilar should the recommended items be. The default value is 0.0, i.e., no diversification. Value 1.0 means maximal diversification.\n   *     - *minRelevance*\n   *         - Type: string\n   *         - Description: **Expert option** If the *targetUserId* is provided:  Specifies the threshold of how much relevant must the recommended items be to the user. Possible values one of: \"low\", \"medium\", \"high\". The default value is \"low\", meaning that the system attempts to recommend number of items equal to *count* at any cost. If there are not enough data (such as interactions or item properties), this may even lead to bestseller-based recommendations to be appended to reach the full *count*. This behavior may be suppressed by using \"medium\" or \"high\" values. In such case, the system only recommends items of at least the requested relevancy, and may return less than *count* items when there is not enough data to fulfill it.\n   *     - *rotationRate*\n   *         - Type: number\n   *         - Description: **Expert option** If the *targetUserId* is provided: If your users browse the system in real-time, it may easily happen that you wish to offer them recommendations multiple times. Here comes the question: how much should the recommendations change? Should they remain the same, or should they rotate? Recombee API allows you to control this per-request in backward fashion. You may penalize an item for being recommended in the near past. For the specific user, `rotationRate=1` means maximal rotation, `rotationRate=0` means absolutely no rotation. You may also use, for example `rotationRate=0.2` for only slight rotation of recommended items.\n   *     - *rotationTime*\n   *         - Type: number\n   *         - Description: **Expert option** If the *targetUserId* is provided: Taking *rotationRate* into account, specifies how long time it takes to an item to recover from the penalization. For example, `rotationTime=7200.0` means that items recommended less than 2 hours ago are penalized.\n   *     - *expertSettings*\n   *         - Type: \n   *         - Description: Dictionary of custom options.\n   *     - *returnAbGroup*\n   *         - Type: boolean\n   *         - Description: If there is a custom AB-testing running, return name of group to which the request belongs.\n   */\n  constructor(itemId, targetUserId, count, optional) {\n    super('POST', `/recomms/items/${itemId}/items/`, 3000, false);\n    this.itemId = itemId;\n    this.targetUserId = targetUserId;\n    this.count = count;\n    optional = optional || {};\n    this.scenario = optional.scenario;\n    this.cascadeCreate = optional.cascadeCreate;\n    this.returnProperties = optional.returnProperties;\n    this.includedProperties = optional.includedProperties;\n    this.filter = optional.filter;\n    this.booster = optional.booster;\n    this.logic = optional.logic;\n    this.userImpact = optional.userImpact;\n    this.diversity = optional.diversity;\n    this.minRelevance = optional.minRelevance;\n    this.rotationRate = optional.rotationRate;\n    this.rotationTime = optional.rotationTime;\n    this.expertSettings = optional.expertSettings;\n    this.returnAbGroup = optional.returnAbGroup;\n  }\n\n  /**\n   * Get body parameters\n   * @return {Object} The values of body parameters (name of parameter: value of the parameter)\n   */\n  bodyParameters() {\n    let params = {};\n    params.targetUserId = this.targetUserId;\n    params.count = this.count;\n\n    if(this.scenario !== undefined)\n      params.scenario = this.scenario;\n\n    if(this.cascadeCreate !== undefined)\n      params.cascadeCreate = this.cascadeCreate;\n\n    if(this.returnProperties !== undefined)\n      params.returnProperties = this.returnProperties;\n\n    if(this.includedProperties !== undefined)\n      params.includedProperties = this.includedProperties;\n\n    if(this.filter !== undefined)\n      params.filter = this.filter;\n\n    if(this.booster !== undefined)\n      params.booster = this.booster;\n\n    if(this.logic !== undefined)\n      params.logic = this.logic;\n\n    if(this.userImpact !== undefined)\n      params.userImpact = this.userImpact;\n\n    if(this.diversity !== undefined)\n      params.diversity = this.diversity;\n\n    if(this.minRelevance !== undefined)\n      params.minRelevance = this.minRelevance;\n\n    if(this.rotationRate !== undefined)\n      params.rotationRate = this.rotationRate;\n\n    if(this.rotationTime !== undefined)\n      params.rotationTime = this.rotationTime;\n\n    if(this.expertSettings !== undefined)\n      params.expertSettings = this.expertSettings;\n\n    if(this.returnAbGroup !== undefined)\n      params.returnAbGroup = this.returnAbGroup;\n\n    return params;\n  }\n\n  /**\n   * Get query parameters\n   * @return {Object} The values of query parameters (name of parameter: value of the parameter)\n   */\n  queryParameters() {\n    let params = {};\n    return params;\n  }\n}\n\nexports.RecommendItemsToItem = RecommendItemsToItem\n"]},"metadata":{},"sourceType":"script"}